\label{index_md_README}%
\Hypertarget{index_md_README}%
This library features a simple header-\/only C++11 circular buffer implementation which I enjoyed using when developing hardware. As the \href{https://en.wikipedia.org/wiki/Circular_buffer}{\texttt{ Wikipedia entry}} for it suggests, circular buffers are useful when storing data streams with a constant amount of memory.

All you need to do to use this library is include the header file {\ttfamily \mbox{\hyperlink{circular_buffer_8h}{circular\+Buffer.\+h}}} in the root directory and you\textquotesingle{}re set!\hypertarget{index_autotoc_md1}{}\doxysection{Documentation}\label{index_autotoc_md1}
Doxy\+Gen documentation for this library is available \href{https://silicondosa.github.io/circularBuffer/}{\texttt{ here}}. You can also find an \href{https://silicondosa.github.io/circularBuffer/circular_buffer_8cpp_source.html}{\texttt{ example here}}.

Importantly, it has \href{https://silicondosa.github.io/circularBuffer/circular_buffer_8h.html\#a7702f4afe06244a0600711520cae3551}{\texttt{ two write modes}}. The {\ttfamily CBUF\+\_\+\+FILL} write mode stops data storage when the buffer is full as is typical in hardware. However, I\textquotesingle{}ve implemented a second write mode {\ttfamily CBUF\+\_\+\+OVERWRITE} which overwrites the most stale data in the buffer with the newest data point. This yeilds a sliding window effect on the data stream---this is useful in real-\/time streaming applications.\hypertarget{index_autotoc_md2}{}\doxysection{Learning outcomes}\label{index_autotoc_md2}
This was an interesting two hour-\/long exercise in converting a hardware/comoputer architecture concept to software. It also helped me refresh my memory of template classes which I use here.\hypertarget{index_autotoc_md3}{}\doxysection{LICENSE}\label{index_autotoc_md3}
This library is licensed under the GNU Lesser General Public License v3. 